package HirakataPapark::Web::Plugin::AssetPack::Pipe::BundleJS {

  use Mojo::Base 'Mojolicious::Plugin::AssetPack::Pipe';
  use HirakataPapark;
  use Path::Tiny qw( path );
  use Config::PL qw( config_do );
  use Data::Dumper;
  use Mojolicious::Plugin::AssetPack::Util qw( diag load_module DEBUG checksum );

  use constant {
    HISTORY_FILE => '.js_histories.db',
    BUNDLE_FILE  => 'bundle.js',
  };

  has 'watch_dir' => './assets/js/';

  has 'history_file_path' => sub ($self) {
    $self->watch_dir . HISTORY_FILE;
  };

  has 'npm_command' => sub ($self) {
    if ($ENV{MOJO_MODE} eq 'development') {
      [qw( npm -s run build-dev )]
    } else {
      [qw( npm -s run build )]
    }
  };

  sub before_process($self, $collection) {
    my $path = path($self->watch_dir . BUNDLE_FILE);
    unless ($path->exists) {
      $self->run($self->npm_command, undef, undef);
    }
  }

  sub process($self, $assets) {
    my $store = $self->assetpack->store;
    $assets->each(sub ($asset, $index) {
      if ($asset->path->basename eq BUNDLE_FILE) {
        my $attr = $asset->TO_JSON;
        $attr->{key} = 'bundle_js';
        if ($self->does_need_update) {
          $self->run($self->npm_command, undef, undef);
          my $content = $asset->path->slurp;
          $attr->{checksum} = checksum $content;
          $asset->content($store->save(\$content, $attr))->FROM_JSON($attr);
        } else {
          my $file = $store->load($attr);
          $asset->content($file)->FROM_JSON($attr);
        }
      }
    });
  }

  sub does_need_update($self) {
    my $watch_dir     = path($self->watch_dir);
    my $watch_dir_abs = $watch_dir->absolute . '/';
    my $iter          = $watch_dir->iterator({ recurse => 1 });
    my @watch_files;
    while ( my $path = $iter->() ) {
      push @watch_files, $path;
    }

    my $history_file = path($self->history_file_path);
    # ファイルが存在しない場合は作る
    unless ( $history_file->exists ) {
      $history_file->touch;
      $history_file->spew_utf8("{}");
    }
    my $history = config_do($self->history_file_path);
    my @update_files = grep {
      my $file = $_;
      if ($file->is_file) {
        my $abs_path = $file->absolute =~ s/$watch_dir_abs//gr;
        if ($abs_path =~ /\.js$/ && $abs_path ne BUNDLE_FILE) {
          my $mtime    = $file->stat->mtime;
          unless (exists $history->{$abs_path}) {
            $history->{$abs_path} = {
              # Path::Tiny object to string
              name  => $abs_path . '',
              mtime => $mtime - 1,
            };
          }
          $history->{$abs_path}{mtime} < $mtime ? ( $history->{$abs_path}{mtime} = $mtime ) : 0;
        } else {
          0;
        }
      } else {
        0;
      }
    } @watch_files;

    if (@update_files) {
      $self->_save_history($history, $history_file);
      \@update_files;
    } else {
      0;
    }
  }

  sub _save_history($self, $history, $history_file) {
    my $dumper = Data::Dumper->new([$history]);
    $dumper->Useperl(0);
    $dumper->Terse(1);
    $dumper->Indent(1);
    my $history_template = <<"EOS";
# manege file of generate file from perl
# this file is generated by @{[ __PACKAGE__ ]}. Don't edit this file;
use utf8;

@{[ $dumper->Dump ]}

EOS
    $history_file->spew_utf8($history_template);
  }

}

1;

__END__

Mojolicious::Plugin::AssetPack でJavaScriptコードの更新を監視し、更新があればコンパイルし直すというモジュール
正直本来の使い方とはだいぶ異なっているので汚いコードだが
こうでもしないとJSをつかった開発がやりにくいため...
全く汎用的でなくやっつけ感が凄いがとりあえず使えればokということで

